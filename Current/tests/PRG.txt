import numpy as np import re import matplotlib.pyplot as plt '''This code will take in a trajectory file generated by my MonteCarlo engine and give you Radius of Gyration'''f = open("coords.txt", "r")coord_file = f.readlines() st_b_str = "Dumping coordinates at step" pmer_num_str = "Dumping coordinates of Polymer"end_str = "~#~#~#~#~#~#~#~#~#~#~#~#~#~#~#~#~#~#~#~#\n" # master_dict will be dictionary which will contain polymer coordinates at each step # chunky data structuremaster_dict = {} xlen, ylen, zlen = 10, 10, 10step_flag = 0 pmer_flag = -1 end_step_flag = 0step_num = 0 # given a string, it will extract all numbers out in chronological order # and put them in a numpy array def extract_loc_from_string(a_string):    loc = [int(word) for word in a_string.split() if word.isdigit()]        return np.asarray(loc) for line in coord_file:     if (re.search(st_b_str, line)):                step_num = int((extract_loc_from_string(line.replace('.', ' ')) ) )                master_dict[step_num] = {}                step_flag = 1        pmer_flag = -1        end_step_flag = 0        continue            elif (re.search(pmer_num_str, line)):        pmer_flag += 1        master_dict[step_num][pmer_flag] = np.empty ( (0,3) )                continue            elif (re.search(end_str, line)):        end_step_flag = 1        step_flag = 0         pmer_flag = -1                continue        else:                monomer_coords = extract_loc_from_string(line)        master_dict[step_num][pmer_flag] = np.vstack( (master_dict[step_num][pmer_flag], monomer_coords) )        continue            def modified_modulo(divident, divisor):    midway = divisor/2    if (divident%divisor > midway):        result = (divident%divisor)-divisor         return result    else:        return divident%divisor         def unfuck_polymer(polymer, x, y, z):     unfucked_polymer = np.asarray([polymer[0,:]])        for i in range ( polymer.shape[0]-1 ) :        diff = polymer[i+1,:] - polymer[i,:]                for j in range(3):            diff[j] = modified_modulo(diff[j], x)                unfucked_polymer = np.vstack( (unfucked_polymer, unfucked_polymer[i]+diff ) )        return unfucked_polymer         def get_Rg(coord_arr):        coord_arr = unfuck_polymer(coord_arr, xlen, ylen, zlen)        # for i in range(coord_arr.shape[0]):    #     for j in range(coord_arr.shape[1]):     #        coord_arr[i,j] = modified_modulo(coord_arr[i,j], xlen)         r_com = np.mean(coord_arr, axis=0)     N = coord_arr.shape[0]    rsum = 0        sc_coords = np.zeros((1,3))        for i in range(N):         rsum += np.linalg.norm( coord_arr[i,:]- r_com )         rsum = rsum/N         return rsum rg = [] steps = [] for key in master_dict:     rg.append( get_Rg(master_dict[key][0]) )     steps.append(key) plt.scatter(steps, rg, s=6)plt.xlabel('Moves performed')plt.ylabel('Radius of gyration ')plt.title('Radius of gyration trend as simulation proceeds')print("min is {} and index is {}".format(np.min(rg), np.argmin(rg)))print("mean is {}".format( np.mean(rg) ) ) print("max is {} and index is {}.".format( np.max(rg), np.argmax(rg) ) )