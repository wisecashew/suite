#!/usr/licensed/anaconda3/2020.7/bin/python

import sys
sys.path.insert(0, "/scratch/gpfs/satyend/MC_POLYMER/polymer_lattice/lattice_md/current/Explicit_Solvation/py_analysis")
import numpy as np 
import re 
import matplotlib
matplotlib.use('Agg')
import matplotlib.cm as cm
import matplotlib.pyplot as plt 
from matplotlib.ticker import StrMethodFormatter
import pandas as pd
import os
import aux 
import time 
import sys 
import multiprocessing 
import itertools

os.system("taskset -p 0xfffff %d" % os.getpid())
os.environ['MKL_NUM_THREADS'] = '1'
os.environ['NUMEXPR_NUM_THREADS'] = '1'
os.environ['OMP_NUM_THREADS'] = '1'

sys.stdout.flush() 

'''
This code will take in a trajectory file generated by my MonteCarlo engine and 
give you Radius of Gyration. 
'''
''' 
shebang for cluster: #!/usr/licensed/anaconda3/2020.7/bin/python
shebang for homemachine: #!/usr/bin/env python3
'''


import argparse 
parser = argparse.ArgumentParser(description="Read a trajectory file and obtain a radius of gyration plot given a degree of polymerization over a range of temperatures and potential energy surfaces.")
parser.add_argument('-dop', metavar='DOP', dest='dop', type=int, action='store', help='enter a degree of polymerization.')
parser.add_argument('-s', metavar='S', type=int, dest='s', action='store', help='start parsing after this move number (not index or line number in file).', default=100)
parser.add_argument('-nproc', metavar='N', type=int, dest='nproc', action='store', help='Request these many proccesses.')
parser.add_argument('--excl-vol', dest='ev', action='store_true', help='Flag to include excluded volume forcefield.', default=False) 
parser.add_argument('--coords', dest='c', metavar='coords.txt', action='store', type=str, help='Name of energy dump file to parse information.', default='coords.txt')
parser.add_argument('--color-scheme', dest='cs', action='store', type=int, help='Type of coloring.')
parser.add_argument('--sim-style', dest='ss', action='store', type=str, help='flory or entropy.')
parser.add_argument('--path-to-excl', dest='pte', metavar='add/ress', action='store', type=str, help='Path to file.')
parser.add_argument('--png-name', dest='pn', metavar='imagename', action='store', type=str, help='Name of image file', default='rg_plot')
parser.add_argument('--show-plot', dest='sp', action='store_true', help='Flag to include to see plot.') 
args = parser.parse_args() 

if args.cs == 3:
    divnorm = matplotlib.colors.SymLogNorm ( 0.5, vmin=0.0, vmax=1.0 ) 
elif args.cs == 0:
    if args.ss == 'flory-huggins':
        divnorm = matplotlib.colors.SymLogNorm ( 0.0001, vmin=-0.2, vmax=0.1 ) # this is for flory-huggins  
    elif args.ss == 'entropy':
        divnorm = matplotlib.colors.SymLogNorm ( 0.001, vmin=-0.2, vmax=0.1 ) # this is for entropy 
    else:
        print ("Bad simstyle.", flush=True)
        exit()

def get_starting_ind ( U, T, num, dop, dumpfile):
    filename = U + "/DOP_" + str(dop) + "/" + str(T) + "/" + dumpfile + "_" + str(num) + ".mc"
    df = pd.read_csv(filename, sep=' \| ', names=["energy", "mm_tot", "mm_aligned", "mm_naligned", "ms1_tot", "ms1_aligned", "ms1_naligned", "ms2_tot", "ms2_aligned", "ms2_naligned", "ms1s2_tot",  "ms1s2_aligned", "ms1s2_naligned", "time_step"], engine='python', skiprows=0)
    L = len(df["energy"])
    return int(df["time_step"].values[L-2000])


def infiltrate_coords_get_rg ( U, T, num, dop, coords_files, starting_index ):

    filename = U + "/DOP_" + str(dop) + "/" + str(T) + "/"+ coords_files + "_" + str(num)+".mc" 
    edge = aux.edge_length (dop)
    master_dict = aux.get_pdict (filename, starting_index, dop, edge, edge, edge)
    rg = get_Rg(master_dict, edge, edge, edge) 
    return rg 


def get_Rg (master_dict, xlen, ylen, zlen):
    
    N = master_dict [ next(iter(master_dict)) ][0].shape[0] 
    
    count = 0
    rg    = []

    for key in master_dict: 
        coord_arr = aux.unfuck_polymer ( master_dict[key][0], xlen, ylen, zlen )
        r_com = np.mean( coord_arr, axis=0) # get center of mass 
        offset = coord_arr - r_com 
        rg.append(np.sqrt(np.sum ( np.square (offset) )/ N)) # added the np.sqrt
        

    return rg

if __name__ == "__main__":    

    start = time.time() 
    ##################################

    # U_list = aux.dir2U ( os.listdir (".") )
    U_list = ["U9"]
    PLOT_DICT = {} 
    dop            = args.dop
    coords_files   = args.c
    starting_index = args.s
    excl_vol_bool  = args.ev
    show_plot_bool = args.sp
    
    ######
    i = 0 
    # Tmax = [] 

    rg_max = (1+np.sqrt(2)+np.sqrt(3))/(3*6**0.5) * (dop**0.57) 
    # instantiating pool
    nproc = args.nproc
    pool1 = multiprocessing.Pool ( processes=nproc )# len(num_list)) 
    
    pool_list = [pool1] 
    

    for U in U_list:
        print("Inside U = " + U + ", and N = " + str(dop) + "...", flush=True )
        rg_mean = [] 
        rg_std  = [] 
        # temperatures = aux.dir2float ( os.listdir( str(U) +"/DOP_"+str(dop) ) )
        temperatures = [0.01, 0.1, 0.2, 0.3, 0.4, 0.5, 1.0, 2.5, 5.0, 10.0, 25.0, 50.0, 100.0]
        # Tmax.append ( np.max(temperatures) )

        # get num_list for each temperature 
        master_temp_list = []
        master_num_list = []
        master_index_list = [] 
        rg_dict    = {}
        ntraj_dict = {}
        for T in temperatures: 
            # print ("T is " + str(T), flush=True) 
            num_list = list(np.unique ( aux.dir2nsim (os.listdir (str(U) + "/DOP_" + str(dop) + "/" + str(T) ) ) ) )
            master_num_list.extend ( num_list )
            for num in num_list:
                master_index_list.append (get_starting_ind (U, T, num, dop, "energydump") )
            master_temp_list.extend ( [T]*len( num_list ) )
            ntraj_dict[T] = len ( num_list )
            rg_dict[T] = []

        # start multiprocessing... keeping in mind that each node only has 96 cores 
        # start splitting up master_num_list and master_temp_list 
        
        idx_range = len (master_num_list)//nproc + 1
        for u_idx in range(idx_range):
            if u_idx == idx_range-1:
                results = pool_list[ 0 ] .starmap ( infiltrate_coords_get_rg, zip( itertools.repeat(U), master_temp_list[u_idx*nproc:], master_num_list[u_idx*nproc:], itertools.repeat(dop), itertools.repeat(coords_files), master_index_list[u_idx*nproc:] ) ) # itertools.repeat(starting_index) ) )
            else:
                results = pool_list[ 0 ] .starmap ( infiltrate_coords_get_rg, zip( itertools.repeat(U), master_temp_list[u_idx*nproc:(u_idx+1)*nproc], master_num_list[u_idx*nproc:(u_idx+1)*nproc], itertools.repeat(dop), itertools.repeat(coords_files), master_index_list[u_idx*nproc:(u_idx+1)*nproc] ) )# itertools.repeat(starting_index) ) )

            print ("Pool has been closed. This pool had {} threads.".format (len(results) ), flush=True )     

            for k in range( len( master_temp_list[u_idx*nproc:(u_idx+1)*nproc] ) ):
                # print ("T = ", master_temp_list[ u_idx*nproc + k ])
                rg_dict[master_temp_list[u_idx*nproc + k]].extend( results[k] )
        
        # for T in np.unique (master_temp_list):
        #     rg_mean.append( np.mean ( rg_dict[T] ) )
        #     rg_std.append ( np.std (rg_dict[T]) / np.sqrt(master_temp_list.count(T)*1.5 ) )
        
        PLOT_DICT [U] = (np.asarray(rg_mean), np.asarray(rg_std))
         
    pool1.close()
    pool1.join()

    print ("rg_max = ", rg_max)
    i=0
    chi_list = [0.1, 0.05, 0.01, 0.001, 0, -0.001, -0.01, -0.1, -0.2]
    # 
    # ax.tick_params (axis='x', labelsize=16)
    # ax.tick_params (axis='y', labelsize=16)
    # ax.minorticks_on()
    for t in temperatures:
        fig = plt.figure( num=i, figsize=(8,6) )
        ax  = plt.axes() 
        ax.tick_params (direction='in', bottom=True, top=True, left=True, right=True, which='both', pad=5, labelsize=12)
        ax.hist ( rg_dict[t], range=(1, 6), bins=np.arange(1,6,0.2), density=True, color='steelblue')
        ax.set_ylim (0, 4.5)
        plt.savefig ( args.pn+"_"+str(t)+".png", bbox_inches='tight', dpi=1200 )
        i += 1

    ########################################

    stop = time.time()
    print ("Run time for N = " + str(args.dop) + " is {:.2f} seconds.".format(stop-start), flush=True)

