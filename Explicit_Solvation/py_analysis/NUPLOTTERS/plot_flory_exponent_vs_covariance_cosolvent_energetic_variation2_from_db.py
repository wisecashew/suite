#!/home/satyend/.conda/envs/data_analysis/bin/python

import numpy as np 
import re 
import matplotlib
matplotlib.use('Agg')
import matplotlib.cm as cm
import matplotlib.pyplot as plt 
import matplotlib.ticker as tck
import pandas as pd
import os
# import aux 
import time 
import sys 
sys.path.insert(0, '/scratch/gpfs/satyend/MC_POLYMER/polymer_lattice/lattice_md/current/Explicit_Solvation/py_analysis')
import aux 
import multiprocessing 
import itertools
from sklearn.linear_model import LinearRegression 
from matplotlib import rc,rcParams

os.system("taskset -p 0xfffff %d" % os.getpid())
os.environ['MKL_NUM_THREADS'] = '1'
os.environ['NUMEXPR_NUM_THREADS'] = '1'
os.environ['OMP_NUM_THREADS'] = '1'

sys.stdout.flush() 

'''
This code will take in a trajectory file generated by my MonteCarlo engine and 
gives you the flory exponent
'''
''' 
shebang for cluster: #!/usr/licensed/anaconda3/2020.7/bin/python
shebang for homemachine: #!/usr/bin/env python3
'''


import argparse 
parser = argparse.ArgumentParser(description="Read a trajectory file and obtain the flory exponent from that file.")
parser.add_argument('--dop', dest='dop', action='store', type=int, help='Size of polymer.')
parser.add_argument('--integrated-database', dest='fd', metavar='df', action='store', type=str, help='Name of dump file.')
parser.add_argument('--energy-dump', dest='ed', metavar='ed', action='store', type=str, help='Name of energy dump file.')
parser.add_argument('--png-name', dest='pn', metavar='imagename', action='store', type=str, help='Name of image.')
args = parser.parse_args() 

divnorm       = matplotlib.colors.SymLogNorm(0.001, vmin=-0.2, vmax=0.1)
divnorm_arrow = matplotlib.colors.Normalize (vmin=0, vmax=1)

def arrowplot(axes, x, y):
	x = np.array(x)
	y = np.array(y)
	for i in range (len(x)-1):
		axes.quiver (x[i], y[i], (x[i+1]-x[i])*0.92, (y[i+1]-y[i])*0.92, angles='xy', scale_units='xy', scale=1, color=cm.coolwarm(divnorm_arrow (i / ( len(x)-2) ) ), edgecolor=None, headwidth=5, headlength=7)

	return




if __name__ == "__main__":
	start = time.time()
	##################################
	rc('font', weight='bold')
	# chi_list = [0.1, 0.05, 0.01, 0.005, 0, -0.01, -0.05, -0.1, -0.2]
	df = pd.read_csv (args.fd, sep='|')
	U_list = aux.dir2U ( os.listdir (".") )
	# col_dict = {}
	# for i in range(len(chi_list)):
	# 	col_dict[U_list[i]] = chi_list[i]
		
	PLOT_DICT = {}
	fig = plt.figure   ( figsize=(4/1.6,4/1.6), constrained_layout=True )
	ax  = plt.axes() 
	ax.tick_params(direction='in', bottom=True, top=True, left=True, right=True, which='both')
	ax.tick_params(axis='x', labelsize=8, labelrotation=0)
	ax.tick_params(axis='y', labelsize=8)
	ax.ticklabel_format(axis='x', style='sci', scilimits=(0,0))
	ax.set (autoscale_on=False)
	aux.gradient_image (ax, direction=0, extent=(0, 1, 0, 1), transform=ax.transAxes, cmap=plt.cm.RdBu_r, cmap_range=(0.2, 0.8), alpha=1)
	i = 0 

	##################################
	i = 0
	enthalpies = np.unique (df["H"]) 
	print ("enthalpies = ",enthalpies, flush=True)
	for H in enthalpies:
		print ("Currently plotting out stuff in U = " + str(U) + "...", end=' ', flush=True)
		Emm_a, Emm_n, Ems1_a, Ems1_n, Ems2_a, Ems2_n, Es1s2_a, Es1s2_n = aux.get_energy (str(U)+"/geom_and_esurf.txt")
		ms_list = np.asarray([])
		ms_err  = np.asarray([])
		ms_mean = np.asarray([])

		for H in enthalpies:
			skip = 0
			ms_list = np.asarray([])
			num_list = np.unique ( aux.dir2nsim( os.listdir ( str(U) + "/DOP_" + str(args.dop) + "/E_" + str(H) ) ) )
			for num in num_list:
				df_cov = pd.read_csv(str(U)+"/DOP_"+str(args.dop)+"/E_"+str(H)+"/"+args.ed+"_"+str(num)+".mc", sep=' \| ', \
				names=["energy", "mm_tot", "mm_aligned", "mm_naligned", "ms1_tot", "ms1_aligned", "ms1_naligned", "ms2_tot", \
				"ms2_aligned", "ms2_naligned", "ms1s2_tot",  "ms1s2_aligned", "ms1s2_naligned", "time_step"], \
				engine='python', skiprows=skip)
				f = df_cov["mm_aligned"].values[-2000:]*Emm_a + df_cov["mm_naligned"].values[-2000:]*Emm_n
				g = df_cov["ms1_aligned"].values[-2000:]*Ems1_a + df_cov["ms1_naligned"].values[-2000:]*Ems1_n
				# f = f/np.mean(f); g = g/np.mean(g); 
				ms_list = np.hstack ( (ms_list, np.mean (f*g) - np.mean(f)*np.mean(g) ) )

			ms_err  = np.hstack ( (ms_err ,  (np.std (ms_list) / np.sqrt(len(num_list)) ) ) )
			ms_mean = np.hstack ( (ms_mean,  np.mean (ms_list) ) )

		PLOT_DICT[H] = ( ms_mean, ms_err )
		print("done!", flush=True)
	
	for U in U_list:
		print ("color = ",col_dict[U])
		rgba_color = cm.PiYG (divnorm(col_dict[U]))
		nu = df.loc[df["U"] == U]
		ax.errorbar (PLOT_DICT[U][0], nu["nu_mean"]/2, yerr=nu["nu_err"]/2, xerr=PLOT_DICT[U][1], linewidth=0, ecolor='k')
		ax.plot(PLOT_DICT[U][0], nu["nu_mean"]/2, linewidth=0, marker='o',markersize=8/1.3, markeredgecolor='k', \
		label="_nolabel_", linestyle='-.', c=rgba_color)
		y = nu["nu_mean"]/2
		x = PLOT_DICT[U][0]
		arrowplot (ax, list(x), list(y))
		i += 1
	stop = time.time() 
	ax.set_yticks (np.arange (0.0, 0.9, 0.1))
	ax.set_ylim (0.0, 0.8)
	ax.set_xlim (-2000, 100)
	ax.set_xticks (np.arange (-2000, 400, 400))
	# ax.set_xticklabels (ax.get_xticks(), weight='bold')
	ax.xaxis.get_offset_text().set_fontsize(6)
	ax.yaxis.set_minor_locator (matplotlib.ticker.AutoMinorLocator())
	ax.xaxis.set_minor_locator (matplotlib.ticker.AutoMinorLocator())
	# plt.gca().xaxis.set_major_formatter (tck.StrMethodFormatter('{x:1.1e}'))
	ax.set_aspect('auto')
	plt.savefig   ( args.pn, bbox_inches='tight', dpi=1200)
	
	print ("Run time is {:.2f} seconds.".format(stop-start), flush=True)

