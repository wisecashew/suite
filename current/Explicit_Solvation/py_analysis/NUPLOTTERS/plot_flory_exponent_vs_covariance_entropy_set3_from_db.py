#!/home/satyend/.conda/envs/data_analysis/bin/python

import numpy as np 
import re 
import matplotlib
matplotlib.use('Agg')
import matplotlib.cm as cm
import matplotlib.pyplot as plt 
import matplotlib.ticker as tck
import pandas as pd
import os
import aux 
import time 
import sys 
import multiprocessing 
import itertools
from sklearn.linear_model import LinearRegression 
from matplotlib import rc,rcParams

os.system("taskset -p 0xfffff %d" % os.getpid())
os.environ['MKL_NUM_THREADS'] = '1'
os.environ['NUMEXPR_NUM_THREADS'] = '1'
os.environ['OMP_NUM_THREADS'] = '1'

sys.stdout.flush() 

'''
This code will take in a trajectory file generated by my MonteCarlo engine and 
gives you the flory exponent
'''
''' 
shebang for cluster: #!/usr/licensed/anaconda3/2020.7/bin/python
shebang for homemachine: #!/usr/bin/env python3
'''


import argparse 
parser = argparse.ArgumentParser(description="Read a trajectory file and obtain the flory exponent from that file.")
parser.add_argument('--dop', dest='dop', action='store', type=int, help='Size of polymer.')
parser.add_argument('--flory-dump', dest='fd', metavar='df', action='store', type=str, help='Name of dump file.')
parser.add_argument('--energy-dump', dest='ed', metavar='ed', action='store', type=str, help='Name of energy dump file.')
parser.add_argument('--png-name', dest='pn', metavar='imagename', action='store', type=str, help='Name of image.')
args = parser.parse_args() 

divnorm       = matplotlib.colors.SymLogNorm(0.001, vmin=-0.2, vmax=0.1)
divnorm_arrow = matplotlib.colors.Normalize (vmin=0, vmax=1)

def arrowplot(axes, x, y):
	x = np.array(x)
	y = np.array(y)
	for i in range (len(x)-1):
		axes.quiver (x[i], y[i], (x[i+1]-x[i])*0.95, (y[i+1]-y[i])*0.95, angles='xy', scale_units='xy', scale=1, color=cm.coolwarm(divnorm_arrow (i / ( len(x)-2) ) ), edgecolor=None, headwidth=5, headlength=7)
	
	return


if __name__ == "__main__":
	start = time.time()
	##################################
	rc('font', weight='bold')
	chi_list = [0.1, 0.05, 0.01, 0.005, 0.001, 0, -0.005, -0.01, -0.05, -0.1, -0.2]
	U_list = aux.dir2U ( os.listdir (".") )
	col_dict = {}
	for i in range(len(chi_list)):
		col_dict[U_list[i]] = chi_list[i]
		
	U_list = ["U1", "U4", "U11"]
	PLOT_DICT = {}
	fig = plt.figure   ( figsize=(4/1.6,3/1.6), constrained_layout=True )
	ax  = plt.axes() 
	ax.tick_params(direction='in', bottom=True, top=True, left=True, right=True, which='both')
	ax.tick_params(axis='x', labelsize=8, labelrotation=0)
	ax.tick_params(axis='y', labelsize=8)
	ax.ticklabel_format(axis='x', style='sci', scilimits=(0,0))
	ax.set (autoscale_on=False)
	aux.gradient_image (ax, direction=0, extent=(0, 1, 0, 1), transform=ax.transAxes, cmap=plt.cm.Spectral_r, cmap_range=(0.2, 0.8), alpha=1)
	i = 0 

	##################################
	df = pd.read_csv (args.fd, sep='|')
	i = 0
	
	for U in U_list:
		temperatures = aux.dir2float ( os.listdir( str(U) +"/DOP_"+str(args.dop) ) )
		# temperatures = [0.01, 0.03, 0.04, 0.05, 0.1, 0.2, 0.4, 0.5, 0.6, 0.7, 1.0, 5.0, 10.0, 25.0, 50.0, 100.0]
		df = df[df["T"].isin (temperatures)]
		print ("Currently plotting out stuff in U = " + str(U) + "...", end=' ', flush=True)
		Emm_a, Emm_n, Ems1_a, Ems1_n, Ems2_a, Ems2_n, Es1s2_a, Es1s2_n = aux.get_energy (str(U)+"/geom_and_esurf.txt")
		ms_list = np.asarray([])
		ms_err  = np.asarray([])
		ms_mean = np.asarray([])

		for temp in temperatures:
			skip = 0
			ms_list = np.asarray([])
			num_list = np.unique ( aux.dir2nsim( os.listdir ( str(U) + "/DOP_" + str(args.dop) + "/" + str(temp) ) ) )
			for num in num_list:
				df_cov = pd.read_csv( str(U)+"/DOP_"+str(args.dop)+"/"+str(temp)+"/"+args.ed+"_"+str(num)+".mc", sep=' \| ', \
				names=["energy", "mm_tot", "mm_aligned", "mm_naligned", "ms1_tot", "ms1_aligned", "ms1_naligned", "ms2_tot", \
				"ms2_aligned", "ms2_naligned", "ms1s2_tot",  "ms1s2_aligned", "ms1s2_naligned", "time_step"], \
				engine='python', skiprows=skip)
				f = df_cov["mm_aligned"].values[-2000:]*Emm_a + df_cov["mm_naligned"].values[-2000:]*Emm_n
				g = df_cov["ms1_aligned"].values[-2000:]*Ems1_a + df_cov["ms1_naligned"].values[-2000:]*Ems1_n
				# f = f/np.mean(f); g = g/np.mean(g); 
				ms_list = np.hstack ( (ms_list, np.mean (f*g) - np.mean(f)*np.mean(g) ) )

			ms_err  = np.hstack ( (ms_err ,  (np.std (ms_list) / np.sqrt(len(num_list)) ) ) )
			ms_mean = np.hstack ( (ms_mean,  np.mean (ms_list) ) )

		PLOT_DICT[U] = ( ms_mean, ms_err )
		print("done!", flush=True)
	
	for U in U_list:
		print ("color = ",col_dict[U])
		rgba_color = cm.PiYG (divnorm(col_dict[U]))
		nu = df.loc[df["U"] == U]
		# ax.errorbar(nu["nu_mean"]/2, PLOT_DICT[U][0], yerr=PLOT_DICT[U][1], xerr=nu["nu_err"]/2, linewidth=0, capsize=2, color=rgba_color, \
		# ecolor='k', fmt='none', label='_nolegend_')
		ax.plot(PLOT_DICT[U][0], nu["nu_mean"]/2, linewidth=0, marker='o',markersize=8/1.3, markeredgecolor='k', \
		label="_nolabel_", linestyle='-.', c=rgba_color)
		y = nu["nu_mean"]/2
		x = PLOT_DICT[U][0]
		arrowplot (ax, list(x), list(y))
		i += 1
	stop = time.time() 
	ax.set_yticks (np.arange (0.2, 0.9, 0.1))
	ax.set_ylim (0.2, 0.8)
	ax.set_xlim (-11000, 1000)
	ax.xaxis.get_offset_text().set_fontsize(8)
	ax.yaxis.set_minor_locator (matplotlib.ticker.AutoMinorLocator())
	ax.xaxis.set_minor_locator (matplotlib.ticker.AutoMinorLocator())
	# plt.gca().xaxis.set_major_formatter (tck.StrMethodFormatter('{x:1.1e}'))
	ax.set_aspect ('auto')
	plt.savefig   ( args.pn, bbox_inches='tight', dpi=1200)
	
	print ("Run time is {:.2f} seconds.".format(stop-start), flush=True)

