#!/usr/licensed/anaconda3/2020.7/bin/python

import numpy as np 
import re 
import pandas as pd
import aux 
import time 
import sys 
import itertools
import copy

sys.stdout.flush() 

'''
This code will take in a trajectory file generated by my MonteCarlo engine and 
give you Radius of Gyration
'''
''' 
shebang for cluster: #!/usr/licensed/anaconda3/2020.7/bin/python
shebang for homemachine: #!/usr/bin/env python3
'''


import argparse 
parser = argparse.ArgumentParser(description="Read a trajectory file and obtain the pdb file for the polymer.")
parser.add_argument('-dop', metavar='DOP', dest='dop', type=int, action='store', help='enter a degree of polymerization.')
parser.add_argument('-s', metavar='S', type=int, dest='s', action='store', help='start parsing after this index.', default=100)
parser.add_argument('--coords', dest='c', metavar='coords.txt', action='store', type=str, help='Name of energy dump file to parse information.', default='coords.txt')
parser.add_argument('-x', dest='x', metavar='X', action='store', type=float, help='Enter x-dimension of box.')
parser.add_argument('-y', dest='y', metavar='Y', action='store', type=float, help='Enter y-dimension of box.')
parser.add_argument('-z', dest='z', metavar='Z', action='store', type=float, help='Enter z-dimension of box.')
parser.add_argument('-pdb', dest='pdb', metavar='a.pdb', action='store', type=str, help='Enter a name for the pdb file.')

args = parser.parse_args() 


if __name__ == "__main__":    

    start = time.time() 
    
    master_dict = aux.get_pdict  (args.c, args.s, args.dop, args.x, args.y, args.z)
    polymer     = aux.unfuck_polymer (master_dict[args.s][0], args.x, args.y, args.z)
    polymer = polymer + 34
    # print (polymer+34)
    f = open (args.pdb, 'w')

    f.write("COMPND    MY_POLYMER\n")
    f.write("AUTHOR    SAT\n")
    fss, sss = aux.get_neighbors (polymer)
    # print ("fss = ", fss)
    # print ("sss = ", sss)
    count = 1 
    for row in polymer:
        f.write ("ATOM  {:>5} {:>2}{:<2} POL P{:>4} {:>8}{:>8}{:>8}{:>6}{:>6}      {:>4}{:<1}\n".format( count, "M", " ", 1, row[0]*10, row[1]*10, row[2]*10, 1.00, 1.00, "M", "M" ) )
        count+=1

    j = 2
    scount = copy.copy(count)
    for sol in fss:
        f.write ("ATOM  {:>5} {:>2}{:<2} SOL  {:>4} {:>8}{:>8}{:>8}{:>6}{:>6}      {:>4}{:<1}\n".format( scount, "F", "S", j, sol[0]*10, sol[1]*10, sol[2]*10, 1.00, 1.00, "F", "S" ) )
        scount += 1
        j += 1
    for sol in sss:
        f.write ("ATOM  {:>5} {:>2}{:<2} SOL  {:>4} {:>8}{:>8}{:>8}{:>6}{:>6}      {:>4}{:<1}\n".format( scount, "S", "S", j, sol[0]*10, sol[1]*10, sol[2]*10, 1.00, 1.00, "S", "S" ) )
        scount += 1
        j += 1

    for i in range(1, count):
        if i == 1:
            f.write ("CONECT{:>5}{:>5}\n".format(i, i+1))
        elif i == count-1:
            f.write ("CONECT{:>5}{:>5}\n".format(i, i-1))
        else:
            f.write("CONECT{:>5}{:>5}{:>5}\n".format(i, i-1, i+1 ))

    f.close() 

    stop = time.time() 

    print ("Run time for N = " + str(args.dop) + " is {:.2f} seconds.".format(stop-start), flush=True)
        
