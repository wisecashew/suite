#!/usr/licensed/anaconda3/2020.7/bin/python

import numpy as np 
import re 
import matplotlib.pyplot as plt 
import math 
import cmath 

'''
This code will take in a trajectory file generated by my MonteCarlo engine and 
give you the monomer-monomer correlation 
'''

import argparse 
parser = argparse.ArgumentParser(description="Read a trajectory file and obtain a radius of gyration histogram.")
parser.add_argument('-i', metavar='ortn_dump', dest='i', action='store', type=str, help='enter address of orientation file')
# parser.add_argument('-d', metavar='d', dest='d', action='store', type=int, help='enter distance between monomer units')

args = parser.parse_args() 

def extract_loc_from_string(a_string):
    loc = [int(word) for word in a_string.split() if word.isdigit()]
    
    return np.asarray(loc)         
    

def modified_modulo(divident, divisor):
    midway = divisor/2
    if (divident%divisor > midway):
        result = (divident%divisor)-divisor 
        return result
    else:
        return divident%divisor         

def orientation_to_complex(i):
    z = complex(math.cos(2*math.pi*i/6), math.sin(2*math.pi*i/6)) 
    return z  

if __name__ == "__main__":
    
    f = open( args.i , "r")
    coord_file = f.readlines() 
    
    st_b_str = "START" 
    end_str_1 = "END." 
    
    # master_dict will be dictionary which will contain polymer coordinates at each step 
    # chunky data structure
    master_dict = {} 
    
    step_flag = 0 
    pmer_flag = -1 
    end_step_flag = 0
    step_num = 0 
    
    # given a string, it will extract all numbers out in chronological order 
    # and put them in a numpy array 
    
    for line in coord_file: 
        if (re.search(st_b_str, line)):
            # get step number...
            step_num = int((extract_loc_from_string(line.replace('.', ' ')) ) )
            # initialize dictionary positions at step number 
            master_dict[step_num] = {}
             
            # initialize some flags 
            step_flag = 1
            pmer_flag = 0
            master_dict[step_num][pmer_flag] = np.asarray([1000])
            end_step_flag = 0
            continue
            
        elif (re.search(end_str_1, line)):
            master_dict[step_num][pmer_flag] = np.delete ( master_dict[step_num][pmer_flag], 0 )
            end_step_flag = 1
            step_flag = 0 
            pmer_flag = 0
            
            continue
        
        else:
            monomer_o = extract_loc_from_string(line)[0] 
            master_dict[step_num][pmer_flag] = np.vstack( (master_dict[step_num][pmer_flag], monomer_o) )
            continue
    
    print(master_dict[96000][0]) 
    corr = [] 
    dop = master_dict[step_num][0].shape[0]
    
    for delta in range(dop):
    # find: < delta (s_i,s_j) >     
        ea_prod = 0 
        for step in master_dict:
            for pmer in master_dict[ step ]:
                for j in range( dop-delta ):
                    if master_dict[step][pmer][j] == master_dict[step][pmer][j+delta]:
                        ea_prod += 1
                            
        # averaging all of the above running summations 
        ea_prod = ea_prod/((step_num/1000+1)*(dop-delta)) 
        corr.append( ea_prod ) 
    
    plt.plot(np.arange(0,dop), corr, '^-') 
    plt.xlabel("$\delta$")
    plt.ylabel("$C_{mm}(\delta)$") 
    plt.xticks(np.arange(0,dop))
    # plt.yticks(np.linspace(0,1,11))
    plt.title("Monomer-monomer spin correlation function")
    plt.show() 


