#!/usr/licensed/anaconda3/2020.7/bin/python

import numpy as np 
import re 
import matplotlib
matplotlib.use('Agg')
import matplotlib.cm as cm
import matplotlib.pyplot as plt 
import pandas as pd
import os
import aux 
import time 
import sys 
import multiprocessing 
import itertools

os.system("taskset -p 0xfffff %d" % os.getpid())
os.environ['MKL_NUM_THREADS'] = '1'
os.environ['NUMEXPR_NUM_THREADS'] = '1'
os.environ['OMP_NUM_THREADS'] = '1'

sys.stdout.flush() 

'''
This code will take in a trajectory file generated by my MonteCarlo engine and 
give you Radius of Gyration
'''
''' 
shebang for cluster: #!/usr/licensed/anaconda3/2020.7/bin/python
shebang for homemachine: #!/usr/bin/env python3
'''


import argparse 
parser = argparse.ArgumentParser(description="Read a trajectory file and obtain a radius of gyration plot given a degree of polymerization over a range of temperatures and potential energy surfaces.")
parser.add_argument('-dop', metavar='DOP', dest='dop', type=int, action='store', help='enter a degree of polymerization.')
parser.add_argument('-s', metavar='S', type=int, dest='s', action='store', help='start parsing after this index.', default=100)
parser.add_argument('--excl-vol', dest='ev', action='store_true', help='Flag to include excluded volume forcefield.', default=False) 
parser.add_argument('--coords', dest='c', metavar='coords.txt', action='store', type=str, help='Name of energy dump file to parse information.', default='coords.txt')
parser.add_argument('--show-plot', dest='sp', action='store_true', help='Flag to include to see plot.') 
args = parser.parse_args() 

divnorm = matplotlib.colors.TwoSlopeNorm (vmin=0.5, vmax=3, vcenter=1.7)

if __name__ == "__main__":    

    start = time.time() 
    ##################################
    # aux.plot_entropy_rg_parallelized_single_dop_all_U_all_T ( args.dop, args.s, args.ev, args.c, args.sp )

    U_list = aux.dir2U ( os.listdir (".") )
    # U_list = ["U1"]
    PLOT_DICT = {} 
    dop            = args.dop
    coords_files   = args.c
    excl_vol_bool  = args.ev
    show_plot_bool = args.sp
    
    ######
    plt.style.use('classic')
    fig = plt.figure( figsize=(2.3,2.3) )
    ax  = plt.axes() 
    ax.tick_params(direction='in', bottom=True, top=True, left=True, right=True)
    ax.tick_params(axis='x', labelsize=6, pad=3.5)
    ax.tick_params(axis='y', labelsize=6, pad=3.5)
    ax.xaxis.set_tick_params(which='major', width=0.3)
    ax.xaxis.set_tick_params(which='minor', width=0.1)
    ax.yaxis.set_tick_params(which='major', width=0.3)
    ax.yaxis.set_tick_params(which='minor', width=0.1) 
    # ax.set_ylim([0,1])
    ax.set_xlim([0.01,100])
    i = 0 
    Tmax = [] 

    rg_max = 0 
    # instantiating pool
    pool1 = multiprocessing.Pool ( processes=50 )# len(num_list)) 
    pool2 = multiprocessing.Pool ( processes=5 )
    
    pool_list = [pool1, pool2]
    
    f = open("RG_DATA_"+str(dop), "w") 

    for U in U_list:
        if U == "U11":
            starting_index = args.s
        elif U=="U1":
            starting_index = args.s/2

        f.write ( "U = " + str(U) + ":\n" )
        print("Inside U = " + U + ", and N = " + str(dop) + "...", flush=True )
        rg_mean = [] 
        rg_std  = [] 
        temperatures = aux.dir2float ( os.listdir( str(U) +"/DOP_"+str(dop) ) )
        Tmax.append ( np.max(temperatures) )
        
        # get num_list for each temperature 
        master_temp_list = [] 
        master_num_list = [] 
        rg_dict    = {}
        ntraj_dict = {}
        for T in temperatures: 
            # print ("T is " + str(T), flush=True) 
            num_list = list(np.unique ( aux.dir2nsim (os.listdir (str(U) + "/DOP_" + str(dop) + "/" + str(T) ) ) ) )
            master_num_list.extend ( num_list )
            master_temp_list.extend ( [T]*len( num_list ) )
            ntraj_dict[T] = len ( num_list )
            rg_dict[T] = []


        # start multiprocessing... keeping in mind that each node only has 96 cores 
        # start splitting up master_num_list and master_temp_list 
        mtemp_list_p1 = master_temp_list[0:50] 
        mtemp_list_p2 = master_temp_list[50:100]
        mtemp_list_p3 = master_temp_list[100:105]
        mtemp_list    = [mtemp_list_p1, mtemp_list_p2, mtemp_list_p3] 

        mnum_list_p1  = master_num_list[0:50]
        mnum_list_p2  = master_num_list[50:100]
        mnum_list_p3  = master_num_list[100:105] 
        mnum_list     = [mnum_list_p1, mnum_list_p2, mnum_list_p3] 

        # it is a shitty dict 
        shitty_dict = {0:0, 1:0, 2:1 }

        for uidx in range(3):
            
            # pool = multiprocessing.Pool ( processes=len(mtemp_list[uidx]) ) # len(num_list)) 
            #with pool as p:
            results = pool_list[ shitty_dict[uidx] ] .starmap ( aux.infiltrate_coords_get_rg, zip( itertools.repeat(U), mtemp_list[uidx],\
                     mnum_list[uidx], itertools.repeat(dop), \
                    itertools.repeat(coords_files), itertools.repeat(starting_index) ) )

            # print (len(results))
            # pool.join() 

            print ("Pool has been closed. This pool has {} threads.".format (len(results) ), flush=True )     

            for k in range(len(mtemp_list[uidx])):
                rg_dict[mtemp_list[uidx][k]].append( results[k] )
        
            for T in np.unique (mtemp_list[uidx]):
                rg_mean.append( np.mean ( rg_dict[T] ) ) 
                rg_std.append ( np.std  ( rg_dict[T] )/ np.sqrt( ntraj_dict[T] ) ) 
        
        if rg_max < np.max (rg_mean):
            rg_max = np.max(rg_mean) 

        PLOT_DICT [U] = (np.asarray(rg_mean), np.asarray(rg_std))
        
        f.write("Rg^2: ") 
        for elem in rg_mean: 
            f.write ( "{:.2f} ".format(elem))
        f.write ("\n") 
        f.write ("Error: ")
        for elem in rg_std: 
            f.write ( "{:.2f} ".format(elem) )
        f.write("\n") 
        f.write("T: ") 
        for elem in temperatures: 
            f.write ( "{:.2f} ".format(elem) ) 
        f.write("\n") 
        i+=1 
        f.flush()  

    pool1.close()
    pool1.join()

    pool2.close()
    pool2.join() 

    f.close() 
    
    i=0
    for U in U_list:
       
        if U == "U1":
            temperatures = aux.dir2float ( os.listdir( str(U) +"/DOP_"+str(dop) ) )
            # temperatures = 
            rg_max = dop*1/6 # ((6+12+np.sqrt(2)+8*np.sqrt(3)) /26)**2*1/6*dop
            ax.plot ( temperatures, np.sqrt(PLOT_DICT[U][0])/np.sqrt(rg_max), linewidth=0.5, c='k', zorder=1, clip_on=False, linestyle='dashed')
            ax.scatter ( temperatures, np.sqrt(PLOT_DICT[U][0])/np.sqrt(rg_max), marker='o', edgecolors='k', c=np.sqrt(PLOT_DICT[U][0])/np.sqrt(rg_max), cmap=cm.PiYG, zorder=10, linewidth=0.5, norm=divnorm, s=15, clip_on=False)
        
        if U=="U11":
            rg_max =  dop*1/6 
            rg_list = np.sqrt(PLOT_DICT[U][0])/np.sqrt(rg_max)
            rg_list_colors = divnorm (rg_list)
            temperatures = aux.dir2float ( os.listdir( str(U) +"/DOP_"+str(dop) ) )
            # print(rg_list)
            ax.plot ( temperatures, rg_list, linewidth=0.5, c='k', zorder=1, clip_on=False, linestyle='dotted')
            ax.scatter ( temperatures, rg_list, marker='^', edgecolors='k', c=rg_list, cmap=cm.PiYG, zorder=11, linewidth=0.5, norm=divnorm, s=15, clip_on=False)
    # plot Uexcl...
    if excl_vol_bool:
        f = open ("RG_DATA_"+str(dop), 'a')
        f.write ( "U = Uexcl:\n")
        temperatures_excl = aux.dir2float ( os.listdir( "Uexcl" +"/DOP_"+str(dop) ) )
        edge = aux.edge_length (dop) 
        rg_mean = []
        rg_std  = [] 
        for T in temperatures_excl:
            rg_list = [] 
            
            filename = "Uexcl/DOP_" + str(dop) + "/" + str(T) + "/" +coords_files
            master_dict = aux.get_pdict ( filename, 0, dop, edge, edge, edge ) 
            for key in master_dict:
                coord_arr = aux.unfuck_polymer ( master_dict[key][0], edge, edge, edge ) 
                r_com     = np.mean ( coord_arr, axis=0 ) 
                offset    = coord_arr - r_com
                rg_list.append ( np.sum ( np.square (offset)/dop ) ) 
            
            rg_mean.append ( np.mean (rg_list) ) 
            rg_std.append  ( np.std  (rg_list) ) 
        
        ax.errorbar ( temperatures, np.ones(len(temperatures))*rg_mean[0]/(rg_max), yerr=0 , fmt='^', markeredgecolor='k', linestyle='-', elinewidth=1, capsize=0, linewidth=1 )
        ax.legend (["Athermal solvent"], loc='upper right', bbox_to_anchor=(1.1, 1.1), fontsize=12)
        
        f.write ("Rg^2: ")
        for j in range (len (temperatures) ):
            f.write ( "{:.2f} ".format (rg_mean[0] ) ) 
        f.write("\n") 
        f.write("Error: ") 
        for j in range(len(temperatures) ):
            f.write( "{:.2f} ".format(0) ) 
        f.write ("\n") 
        for elem in temperatures:
            f.write ( "{:.2f} ".format(elem) ) 
        f.write ("\n") 
        f.flush()
        f.close() 
    
    ########################################

    my_cmap = cm.PiYG
    sm = plt.cm.ScalarMappable ( cmap=my_cmap,norm=divnorm )
    cbar = plt.colorbar(sm, orientation='vertical') 
    cbar.set_ticks ( [] )
    # cbar.set_ticklabels( ["Globule", "Gaussian", "Coil"] ) 
    cbar.ax.tick_params(labelsize=4, width=0.1, pad=0.5)
    # cbar.ax.set_ylabel ("State of polymer", fontsize=6, rotation=270, labelpad=9)
    cbar.outline.set_visible(False)
    ax.set_xscale('log')
    # ax.set_xlabel ( "$T^*$", fontsize=4, labelpad=0) 
    # ax.set_ylabel ( "$\\langle R_g^2 \\rangle/ \\langle R_g ^2 \\rangle _{\\mathrm{max}}$", fontsize=4, labelpad=0)     
    # ax.set_yticks (np.linspace(0, 1, 6)) 
    plt.tight_layout()
    plt.savefig   ( "DOP_"+str(dop)+"_multiple_rg.png", dpi=1000)
    
    # if show_plot_bool:
    #    plt.show() 



    ##################################
    stop = time.time() 

    print ("Run time for N = " + str(args.dop) + " is {:.2f} seconds.".format(stop-start), flush=True)
        
