import numpy as np 
import re 
import matplotlib.pyplot as plt 

'''
This code will take in a trajectory file generated by my MonteCarlo engine and 
give you Radius of Gyration
'''

import argparse 
parser = argparse.ArgumentParser(description="Read a trajectory file and end-to-end correlation function.")
parser.add_argument('-i', metavar=': input coordinate file from which Rg is calculated (coords.txt)', dest='i', action='store', help='enter address of coordinate file')
parser.add_argument('-e', metavar=': edge length of the box in which the simulation was conducted', type=int, dest='e', action='store', help='enter the edge length of the cubic simulation box')
args = parser.parse_args() 

def extract_loc_from_string(a_string):
    loc = [int(word) for word in a_string.split() if word.isdigit()]
    
    return np.asarray(loc) 


        
    

def modified_modulo(divident, divisor):
    midway = divisor/2
    if (divident%divisor > midway):
        result = (divident%divisor)-divisor 
        return result
    else:
        return divident%divisor         


def unfuck_polymer(polymer, x, y, z): 
    unfucked_polymer = np.asarray([polymer[0,:]])
    
    for i in range ( polymer.shape[0]-1 ) :
        diff = polymer[i+1,:] - polymer[i,:]
        
        for j in range(3):
            diff[j] = modified_modulo(diff[j], x)
        
        unfucked_polymer = np.vstack( (unfucked_polymer, unfucked_polymer[i]+diff ) )
    
    return unfucked_polymer         


def get_Rg(coord_arr, xlen, ylen, zlen):
    
    coord_arr = unfuck_polymer(coord_arr, xlen, ylen, zlen)
    
    # for i in range(coord_arr.shape[0]):
    #     for j in range(coord_arr.shape[1]): 
    #        coord_arr[i,j] = modified_modulo(coord_arr[i,j], xlen) 
    
    r_com = np.mean(coord_arr, axis=0) 
    N = coord_arr.shape[0]
    rsum = 0
    
    # sc_coords = np.zeros((1,3))
    
    for i in range(N): 
        rsum += np.linalg.norm( coord_arr[i,:]- r_com ) 
    
    rsum = rsum/N 
    
    return rsum 

def get_e2e(coord_arr, xlen, ylen, zlen): 
    coord_arr = unfuck_polymer(coord_arr, xlen, ylen, zlen) 
    
    e2e = coord_arr[-1] - coord_arr[0] 
    return e2e 


if __name__ == "__main__":
    

    
    
    f = open( args.i , "r")
    # f = open("coords.txt", 'r')
    coord_file = f.readlines() 
    f.close() 
    
    st_b_str = "Dumping coordinates at step" 
    pmer_num_str = "Dumping coordinates of Polymer"
    end_str = "~#~#~#~#~#~#~#~#~#~#~#~#~#~#~#~#~#~#~#~#\n" 
    
    # master_dict will be dictionary which will contain polymer coordinates at each step 
    # chunky data structure
    master_dict = {} 
    
    xlen, ylen, zlen = args.e, args.e, args.e
    
    step_flag = 0 
    pmer_flag = -1 
    end_step_flag = 0
    step_num = 0 
    
    # given a string, it will extract all numbers out in chronological order 
    # and put them in a numpy array 
    
    for line in coord_file: 
        if (re.search(st_b_str, line)):
            
            step_num = int((extract_loc_from_string(line.replace('.', ' ')) ) )
            
            master_dict[step_num] = {}
            
            step_flag = 1
            pmer_flag = -1
            end_step_flag = 0
            continue
            
        elif (re.search(pmer_num_str, line)):
            pmer_flag += 1
            master_dict[step_num][pmer_flag] = np.empty ( (0,3) )
            
            continue
            
        elif (re.search(end_str, line)):
            end_step_flag = 1
            step_flag = 0 
            pmer_flag = -1
            
            continue
        
        else:
            
            monomer_coords = extract_loc_from_string(line)
            master_dict[step_num][pmer_flag] = np.vstack( (master_dict[step_num][pmer_flag], monomer_coords) )
            continue
    
    e2e = [] 
    for key in master_dict: 
        e2e.append( get_e2e(master_dict[key][0], xlen, ylen, zlen ) ) 
    
    auto_corr = [] 
    delays = np.arange(0, int(len(e2e)/2))
    
    for i in range(int(len(e2e)/2)): 
        rsum=0 
        for j in range(len(e2e) - i ): 
            # print(j)
            rsum += np.dot(e2e[j], e2e[j+i]) 
        rsum = rsum/(len(e2e)-i) 
        # print(len(e2e)-i)
        auto_corr.append(rsum) 
    
    auto_corr = auto_corr/auto_corr[0] 
    
    plt.plot(delays, auto_corr, '-')
    plt.xlabel("$\delta$")
    plt.ylabel("$ \\frac { \\langle R(\delta) R(0) \\rangle } { \\langle R(0) \\cdot R(0) \\rangle }$")
    plt.savefig("end2end_autocorr.png", dpi=1200) 
    # plt.show() 
    
    
    
    
