#!/usr/licensed/anaconda3/2020.7/bin/python

import numpy as np 
import re 
import matplotlib.pyplot as plt 

'''
This code will take in a trajectory file generated by my MonteCarlo engine and 
give you Radius of Gyration
'''

import argparse 
parser = argparse.ArgumentParser(description="Read a trajectory file and obtain a radius of gyration histogram.")
parser.add_argument('-i', metavar=': input coordinate file from which Rg is calculated (coords.txt)', dest='i', action='store', help='enter address of coordinate file')
parser.add_argument('-e', metavar=': edge length of the box in which the simulation was conducted', type=int, dest='e', action='store', help='enter the edge length of the cubic simulation box')
parser.add_argument('-T', metavar=': thermodynamic temperature', type=float, dest='T', action='store', help='enter the thermodynamic temperature T of the simulation with k = 1 ')
parser.add_argument('

args = parser.parse_args() 

def extract_loc_from_string(a_string):
    loc = [int(word) for word in a_string.split() if word.isdigit()]
    
    return np.asarray(loc) 


        
    

def modified_modulo(divident, divisor):
    midway = divisor/2
    if (divident%divisor > midway):
        result = (divident%divisor)-divisor 
        return result
    else:
        return divident%divisor         


def unfuck_polymer(polymer, x, y, z): 
    unfucked_polymer = np.asarray([polymer[0,:]])
    
    for i in range ( polymer.shape[0]-1 ) :
        diff = polymer[i+1,:] - polymer[i,:]
        
        for j in range(3):
            diff[j] = modified_modulo(diff[j], x)
        
        unfucked_polymer = np.vstack( (unfucked_polymer, unfucked_polymer[i]+diff ) )
    
    return unfucked_polymer         


def get_Rg(coord_arr, xlen, ylen, zlen):
    
    coord_arr = unfuck_polymer(coord_arr, xlen, ylen, zlen)
    
    # for i in range(coord_arr.shape[0]):
    #     for j in range(coord_arr.shape[1]): 
    #        coord_arr[i,j] = modified_modulo(coord_arr[i,j], xlen) 
    
    r_com = np.mean(coord_arr, axis=0) 
    N = coord_arr.shape[0]
    rsum = 0
    
    # sc_coords = np.zeros((1,3))
    
    for i in range(N): 
        rsum += np.linalg.norm( coord_arr[i,:]- r_com ) 
    
    rsum = rsum/N 
    
    return rsum 


if __name__ == "__main__":
    
    #parser = argparse.ArgumentParser(description="Read a trajectory file and obtain a radius of gyration histogram.")
    #parser.add_argument('-i', metavar='coordinate files (coords.txt)', dest='i', action='store', help='enter address of coordinate file')
    #parser.add_argument('-e', metavar='edge length', type=int, dest='e', action='store', help='enter the edge length of the cubic simulation box')
    #parser.add_argument('-T', metavar='thermodynamic temperature', type=float, dest='T', action='store', help='enter the thermodynamic temperature T of the simulation with k = 1 ')
    #args = parser.parse_args() 
    
    
    f = open( args.i , "r")
    coord_file = f.readlines() 
    
    st_b_str = "Dumping coordinates at step" 
    pmer_num_str = "Dumping coordinates of Polymer"
    start_str = "START"
    end_str_1 = "END" 
    end_str_2 = "~#~#~#~#~#~#~#~#~#~#~#~#~#~#~#~#~#~#~#~#\n" 
    
    # master_dict will be dictionary which will contain polymer coordinates at each step 
    # chunky data structure
    master_dict = {} 
    
    xlen, ylen, zlen = args.e, args.e, args.e
    
    step_flag = 0 
    pmer_flag = -1 
    end_step_flag = 0
    step_num = 0 
    
    # given a string, it will extract all numbers out in chronological order 
    # and put them in a numpy array 
    
    for line in coord_file: 
        if (re.search(st_b_str, line)):
            
            step_num = int((extract_loc_from_string(line.replace('.', ' ')) ) )
            
            master_dict[step_num] = {}
            
            step_flag = 1
            pmer_flag = -1
            end_step_flag = 0
            continue
        
        elif (re.search(start_str, line)):
            continue

        elif (re.search(pmer_num_str, line)):
            pmer_flag += 1
            master_dict[step_num][pmer_flag] = np.empty ( (0,3) )
            
            continue
            
        elif (re.search(end_str_1, line)):
            end_step_flag = 1
            step_flag = 0 
            pmer_flag = -1
            continue

        elif (re.search(end_str_2, line)):
            continue
        
        else:
            monomer_coords = extract_loc_from_string(line)
            master_dict[step_num][pmer_flag] = np.vstack( (master_dict[step_num][pmer_flag], monomer_coords) )
            continue
    
    
    rg = [] 
    steps = [] 
    
    for key in master_dict: 
        rg.append( get_Rg(master_dict[key][0], xlen, ylen, zlen) ) 
        steps.append(key) 
    
    
    plt.hist(rg, density=True, bins=100)
    plt.xlabel('Radius of gyration')
    plt.ylabel('Frequency')
    plt.title('Radius of gyration trend as phase space is sampled')
    print("min is {} and index is {}".format(np.min(rg), np.argmin(rg)))
    print("mean is {}".format( np.mean(rg) ) ) 
    print("max is {} and index is {}.".format( np.max(rg), np.argmax(rg) ) ) 
    plt.savefig('rg_kT'+ str(args.T) + '.png',dpi=1200)
    
    g = open('stat_kt' + str(args.T) + '.txt', 'w')
    g.write("min is {} and index is {}\n".format(np.min(rg), np.argmin(rg))) 
    g.write("mean is {}\n".format( np.mean(rg) ) ) 
    g.write("max is {} and index is {}.\n".format( np.max(rg), np.argmax(rg) ) )
    g.write("stderror is {}".format( np.std(rg)/np.sqrt(len(rg) ) ) )
    g.close() 
