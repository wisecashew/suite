#!/usr/licensed/anaconda3/2020.7/bin/python

import numpy as np 
import re 
import matplotlib.pyplot as plt 
import math 
import cmath 

'''
This code will take in a trajectory file generated by my MonteCarlo engine and 
give you the monomer-solvent correlation.
'''

import argparse 
parser = argparse.ArgumentParser(description="Read a trajectory file and obtain a monomer-solvent correlation.")
parser.add_argument('-i', metavar='ortn_dump', dest='i', action='store', type=str, help='enter address of orientation file')

args = parser.parse_args() 

def extract_loc_from_string(a_string):
    loc = [int(word) for word in a_string.split() if word.isdigit()]
    
    return np.asarray(loc)         
    

def modified_modulo(divident, divisor):
    midway = divisor/2
    if (divident%divisor > midway):
        result = (divident%divisor)-divisor 
        return result
    else:
        return divident%divisor         

def orientation_to_complex(i):
    
    z = complex(math.cos(2*math.pi*i/6), math.sin(2*math.pi*i/6)) 
    return z  

if __name__ == "__main__":
    
    f = open( args.i , "r")
    coord_file = f.readlines() 
    
    st_b_str = "START" 
    end_str_1 = "END." 
    
    # master_dict will be dictionary which will contain polymer coordinates at each step 
    # chunky data structure
    master_dict = {} 
    
    step_flag = 0 
    pmer_flag = -1 
    end_step_flag = 0
    step_num = 0 
    
    # given a string, it will extract all numbers out in chronological order 
    # and put them in a numpy array 
    
    for line in coord_file: 
        if (re.search(st_b_str, line)):
            # get step number...
            step_num = int((extract_loc_from_string(line.replace('.', ' ')) ) )
            # initialize dictionary positions at step number 
            master_dict[step_num] = {}
             
            # initialize some flags 
            step_flag = 1
            pmer_flag = 0
            master_dict[step_num][pmer_flag] = []
            end_step_flag = 0
            continue
            
        elif (re.search(end_str_1, line)):
            # master_dict[step_num][pmer_flag] = np.delete ( master_dict[step_num][pmer_flag], 0 )
            end_step_flag = 1
            step_flag = 0 
            pmer_flag = 0
            
            continue
        
        else:
            monomer_o = extract_loc_from_string(line)
            master_dict[step_num][pmer_flag].append( monomer_o )
            continue
    
    dop = len(master_dict[step_num][0])

    # find: < delta (s_m, s_s) >  
    ea_prod = 0 
    ea_prod_normalizer = 0
     
    for step in master_dict:
        for pmer in master_dict[ step ]:
            for j in range( dop ):
                # print(element)
                print(master_dict[step][pmer] )
                print(step)
                for element in master_dict[step][pmer][j][1:] :
                    ea_prod_normalizer += 1
                    if master_dict[step][pmer][j][0] == element:
                        ea_prod += 1
                    
    
    # averaging all of the above running summations 
    ea_prod = ea_prod / ( ea_prod_normalizer )  
    print( "< delta (s_m2, s_m2) > = ", end='') 
    print( ea_prod ) 
    

    
